from collections import defaultdict
from io import StringIO
import os

from . import cw_ast
from .. import version


UNDEFINED = '__UNDEFINED__'


CODE_HEADER = """\
# This code was automatically generated by CWrap version %s

""" % version.version()


class Code(object):

    def __init__(self):
        self._io = StringIO()
        self._indent_level = 0
        self._indentor = ' ' * 4

    def indent(self, n=1):
        self._indent_level += n

    def dedent(self, n=1):
        self._indent_level -= n

    def write_i(self, code):
        indent = self._indentor * self._indent_level
        lines = (indent + line for line in code.splitlines())
        code = '\n'.join(lines)
        self._io.write(code)

    def write(self, code):
        self._io.write(code)
                    
    def newline(self, n=1):
        self._io.write('\n' * n)
    
    def getvalue(self):
        res = CODE_HEADER + self._io.getvalue()
        return res


class ASTRenderer(object):

    def __init__(self):
        self.code = None
        self.cdef_stmt_context = []

    #--------------------------------------------------------------------------
    # Dispatch methods
    #--------------------------------------------------------------------------
    def render(self, module):
        if not isinstance(module, cw_ast.Module):
            msg = ('.render(...) must be called with a Module node as ' 
                   'argument. Got `%s` instead.' % type(module))
            raise TypeError(msg)
        self.code = Code()
        self.cdef_stmt_context = []
        self.visit(module)
        return self.code.getvalue()

    def visit(self, node):
        method_name = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method_name, self.unhandled_visitor)
        visitor(node)

    def visit_render(self, node):
        method_name = 'render_' + node.__class__.__name__
        renderer = getattr(self, method_name, self.unhandled_renderer)
        return renderer(node)

    def unhandled_visitor(self, node):
        print('No visitor for node: `%s`' % node)

    def unhandled_renderer(self, node):
        import pdb; pdb.set_trace()
        print('No renderer for node: `%s`' % node)
        return UNDEFINED

    #--------------------------------------------------------------------------
    # cw_ast.mod Handlers
    #--------------------------------------------------------------------------
    def visit_Module(self, mod):
        for stmt in mod.body:
            self.visit(stmt)
            self.code.newline()

    #--------------------------------------------------------------------------
    # cw_ast.stmt Handlers
    #--------------------------------------------------------------------------`
    def visit_FunctionDef(self, func_def):
        name = func_def.name
        args = self.visit_render(func_def.args)
        decs = [self.visit_render(dec) for dec in func_def.decorator_list]
        
        for dec in decs:
            self.code.write_i('@%s' % dec)
            self.code.newline()

        self.code.write_i('def %s(%s):' % (name, args))
        self.code.newline()

        self.code.indent()
        for stmt in func_def.body:
            self.visit(stmt)
        self.code.dedent()
        
        self.code.newline()

    def visit_ClassDef(self, cls_def):
        name = cls_def.name
        bases = [self.visit_render(base) for base in cls_def.bases]
        decs = [self.visit_render(dec) for dec in cls_def.decorator_list]

        for dec in decs:
            self.code.write_i('@%s' % dec)
            self.code.newline()

        self.code.write_i('class %s(%s):' % (name, ', '.join(bases)))
        self.code.newline()

        self.code.indent()
        for stmt in cls_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_Return(self, ret):
        if ret.value:
            val = self.visit_render(ret.value)
            txt = 'return %s' % val
        else:
            txt = 'return'
        self.code.write_i(txt)
        self.code.newline()

    def visit_Delete(self, delete):
        targets = [self.visit_render(targ) for targ in delete.targets]
        self.code.write_i('del %s' % ', '.join(targets))
        self.code.newline()

    def visit_Assign(self, assign):
        targets = [self.visit_render(targ) for targ in assign.targets]
        value = self.visit_render(assign.value)
        self.code.write_i('%s = %s' % (', '.join(targets), value))
        self.code.newline()

    def visit_AugAssign(self, aug_assign):
        target = self.visit_render(aug_assign.target)
        op = self.visit_render(aug_assign.op)
        value = self.visit_render(aug_assign.value)
        self.code.write_i('%s %s %s' % (target, op, value))
        self.code.newline()

    def visit_Print(self, print_node):
        if print_node.dest:
            dest = self.visit_render(print_node.dest)
        else:
            dest = None
        values = [self.visit_render(val) for val in print_node.values]

        if dest:
            txt = 'print >> %s, %s' % (dest, ', '.join(values))
        else:
            txt = 'print %s' % (', '.join(values))

        if not print_node.nl:
            txt += ','

        self.code.write_i(txt)
        self.code.newline()

    def visit_For(self, for_node):
        target = self.visit_render(for_node.target)
        iter = self.visit_render(for_node.iter)

        self.code.write_i('for %s in %s:' % (target, iter))
        self.code.newline()

        self.code.indent()
        for stmt in for_node.body:
            self.visit(stmt)
        self.code.dedent()
        
        if for_node.orelse:
            self.code.write_i('else:')
            self.code.newline()
            
            self.code.indent()
            for stmt in for_node.orelse:
                self.visit(stmt)
            self.code.dedent()

    def visit_While(self, while_node):
        test = self.visit_render(while_node.test)

        self.code.write_i('while %s:' % test)
        self.code.newline()

        self.code.indent()
        for stmt in while_node.body:
            self.visit(stmt)
        self.code.dedent()

        if while_node.orelse:
            self.code.write_i('else:')
            self.code.newline()

            self.code.indent()
            for stmt in while_node.orelse:
                self.visit(stmt)
            self.code.dedent()

    def visit_If(self, if_node):
        test = self.visit_render(if_node.test)

        self.code.write_i('if %s:' % test)
        self.code.newline()

        self.code.indent()
        for stmt in if_node.body:
            self.visit(stmt)
        self.code.dedent()

        if if_node.orelse:
            self.code.write_i('else:')
            self.code.newline()

            self.code.indent()
            for stmt in if_node.orelse:
                self.visit(stmt)
            self.code.dedent()
        
    def visit_With(self, with_node):
        context = self.visit_render(with_node.context_expr)
        if with_node.optional_vars:
            optional = self.visit_render(with_node.optional_vars)
        else:
            optional = None
        
        if optional:
            self.code.write_i('with %s as %s:' % (context, optional))
        else:
            self.code.write_i('with %s:' % context)
        self.code.newline()

        self.code.indent()
        for stmt in with_node.body:
            self.visit(stmt)
        self.code.dedent()

    def visit_Raise(self, raise_node):
        if raise_node.type:
            type = self.visit_render(raise_node.type)
        else:
            type = None

        if raise_node.inst:
            inst = self.visit_render(raise_node.inst)
        else:
            inst = None

        if raise_node.tback:
            tback = self.visit_render(tback)
        else:
            tback = None

        items = []
        if type:
            items.append(type)
        if inst:
            items.append(inst)
        if tback:
            items.append(tback)

        if items:
            self.code.write_i('raise %s' % (', '.join(items)))
        else:
            self.code.write_i('raise')
        
        self.code.newline()

    def visit_TryExcept(self, try_except):
        self.code.write_i('try:')
        self.code.newline()

        self.code.indent()
        for stmt in try_except.body:
            self.visit(stmt)
        self.code.dedent()

        for handler in try_except.handlers:
            self.visit(handler)
        
        if try_except.orelse:
            self.code.write_i('else:')
            self.code.newline()

            self.code.indent()
            for stmt in try_except.orelse:
                self.visit(stmt)
            self.code.dedent()

        self.code.newline()

    def visit_TryFinally(self, try_finally):
        for stmt in try_finally.body:
            self.visit(stmt)
        self.code.write_i('finally:')
        self.code.newline()

        self.code.indent()
        for stmt in try_finally.finalbody:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_Assert(self, assert_node):
        test = self.visit_render(assert_node.test)
        if assert_node.msg:
            msg = self.visit_render(assert_node.msg)
        else:
            msg = None

        if msg:
            self.code.write_i('assert %s, %s' % (test, msg))
        else:
            self.code.write_i('assert %s' % test)

        self.code.newline()

    def visit_Import(self, import_node):
        names = [self.visit_render(name) for name in import_node.names]
        self.code.write_i('import %s' % (', '.join(names)))
        self.code.newline()

    def visit_ImportFrom(self, import_from):
        if import_from.module:
            module = import_from.module
        else:
            module = ''

        names = [self.visit_render(name) for name in import_from.names]
        names = ', '.join(names)

        if import_from.level:
            level = '.' * import_from.level
        else:
            level = ''

        self.code.write_i('from %s import %s' % (level + module, names))
        self.code.newline()

    def visit_Exec(self, exec_node):
        body = self.visit_render(exec_node.body)
        
        if exec_node.globals:
            globals = self.visit_render(exec_node.globals)
        else:
            globals = None
        
        if exec_node.locals:
            locals = self.visit_render(exec_node.locals)
        else:
            locals = None
        
        items = [body]
        if globals:
            items.append(globals)
        if locals:
            items.append(locals)

        self.code.write_i('exec %s' % (', '.join(items)))
        self.code.newline()

    def visit_Global(self, global_node):
        names = global_node.names
        self.code.write_i('global %s' % (', '.join(names)))
        self.code.newline()

    def visit_Expr(self, expr):
        expr = self.visit_render(expr.value)
        self.code.write_i(expr)
        self.code.newline()

    def visit_Pass(self, pass_node):
        self.code.write_i('pass')
        self.code.newline()

    def visit_Break(self, break_node):
        self.code.write_i('break')
        self.code.newline()

    def visit_Continue(self, continue_node):
        self.code.write_i('continue')
        self.code.newline()

    def visit_ExceptHandler(self, except_handler):
        if except_handler.name:
            name = self.visit_render(except_handler.name)
        else:
            name = None

        if except_handler.type:
            type = self.visit_render(except_handler.type)
        else:
            type = None

        if not name and not type:
            self.code.write_i('except:')
        elif name and type:
            self.code.write_i('except %s as %s:' % (name, type))
        else:
            self.code.write_i('except %s:' % type)
        self.code.newline()

        self.code.indent()
        for stmt in except_handler.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()
    
    def visit_CdefDecl(self, cdef_decl):
        # this is a bit weird since we need to cdef then write a stmt
        # so we put the cdef decl in a context and let the child 
        # handle it
        modifiers = [self.visit_render(mod) for mod in cdef_decl.modifiers]
        items = ['cdef'] + modifiers
        self.cdef_stmt_context.append(' '.join(items))
        self.visit(cdef_decl.value)

    def visit_CpdefDecl(self, cpdef_decl):
        self.cdef_stmt_context.append('cpdef')
        self.visit(cpdef_decl.value)

    def visit_CFunctionDecl(self, cfunc_decl):
        if self.cdef_stmt_context:
            cdef_mods = self.cdef_stmt_context.pop()
        else:
            cdef_mods = None

        name = cfunc_decl.name
        args = self.visit_render(cfunc_decl.args)
        res = '%s(%s)' % (name, args)

        if cfunc_decl.returns:
            mods, type_node = self.extract_reference_types(cfunc_decl.returns)
            returns = self.visit_render(type_node)
            res = self.apply_reference_types(mods, res)
            if isinstance(type_node, cw_ast.CFunctionType):
                res = returns.replace('{__name__}', res)
            else:
                res = '%s %s' % (returns, res)

        if cfunc_decl.excepts:
            excepts = self.visit_render(cfunc_decl.excepts)
            res = '%s excepts %s' % (res, excepts)

        if cdef_mods:
            res = '%s %s' % (cdef_mods, res)
       
        self.code.write_i(res)
        self.code.newline(2)
        
    def visit_CFunctionDef(self, cfunc_def):
        if self.cdef_stmt_context:
            cdef_mods = self.cdef_stmt_context.pop()
        else:
            cdef_mods = None
            
        for decorator in cfunc_def.decorator_list:
            dec = self.visit_render(decorator)
            self.code.write_i('@%s' % dec)
            self.code.newline()
        
        name = cfunc_def.name
        args = self.visit_render(cfunc_def.args)
        res = '%s(%s)' % (name, args)

        if cfunc_def.returns:
            mods, type_node = self.extract_reference_types(cfunc_decl.returns)
            returns = self.visit_render(type_node)
            res = self.apply_reference_types(mods, res)
            if isinstance(type_node, cw_ast.CFunctionType):
                res = returns.replace('{__name__}', res)
            else:
                res = '%s %s' % (returns, res)
        
        if cfunc_decl.excepts:
            excepts = self.visit_render(cfunc_decl.excepts)
            res = '%s excepts %s' % (res, excepts)

        if cdef_mods:
            res = '%s %s' % (cdef_mods, res)
        
        res += ':'
        self.code.write_i(res)
        self.code.newline()
        
        self.code.indent()
        for stmt in cfunc_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_CImport(self, cimport):
        names = [self.visit_render(name) for name in cimport.names]
        self.code.write_i('cimport %s' % (', '.join(names)))
        self.code.newline()

    def visit_CImportFrom(self, cimport_from):
        if cimport_from.module:
            module = cimport_from.module
        else:
            module = ''

        names = [self.visit_render(name) for name in cimport_from.names]
        names = ', '.join(names)

        if cimport_from.level:
            level = '.' * cimport_from.level
        else:
            level = ''

        self.code.write_i('from %s cimport %s' % (level + module, names))
        self.code.newline()

    def visit_CTypedefDecl(self, ctypedef_decl):
        self.cdef_stmt_context.append('ctypedef')
        self.visit(ctypedef_decl.value)
        self.code.newline()

    def visit_CppClassDef(self, cls_def):
        name = cls_def.name
        if self.cdef_stmt_context:
            mod = self.cdef_stmt_context.pop()
            head = '%s cppclass %s:' % (mod, name)
        else:
            head = 'cppclass %s:'%name
        self.code.write_i(head)
        self.code.newline()

        self.code.indent()
        for stmt in cls_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_StructDef(self, struct_def):
        name = struct_def.name
        if self.cdef_stmt_context:
            mod = self.cdef_stmt_context.pop()
            head = '%s struct %s:' % (mod, name)
        else:
            head = 'struct %s:' % name
        self.code.write_i(head)
        self.code.newline()

        self.code.indent()
        for stmt in struct_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_UnionDef(self, union_def):
        name = union_def.name
        if self.cdef_stmt_context:
            mod = self.cdef_stmt_context.pop()
            head = '%s union %s:' % (mod, name)
        else:
            head = 'union %s:' % name
        self.code.write_i(head)
        self.code.newline()

        self.code.indent()
        for stmt in union_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()

    def visit_EnumDef(self, enum_def):
        name = enum_def.name
        if self.cdef_stmt_context:
            mod = self.cdef_stmt_context.pop()
            if name:
                head = '%s enum %s:' % (mod, name)
            else:
                head = '%s enum:' % mod
        else:
            if name:
                head = 'enum %s:' % name
            else:
                head = 'enum:'
        self.code.write_i(head)
        self.code.newline()

        self.code.indent()
        for stmt in enum_def.body:
            self.visit(stmt)
        self.code.dedent()

        self.code.newline()
    
    def visit_Property(self, prop):
        name = prop.name
        self.code.write_i('property %s:' % name)
        self.code.indent()
        self.code.newline()
        for stmt in prop.body:
            self.visit(stmt)
        self.code.dedent()
        
    def visit_ExternFrom(self, extern_from):
        name = extern_from.name
        if self.cdef_stmt_context:
            mod = self.cdef_stmt_context.pop()
            head = '%s extern from "%s":' % (mod, name)
        else:
            head = 'extern from "%s":' % name
        self.code.write_i(head)
        self.code.newline(2)
        self.code.indent()
        for stmt in extern_from.body:
            self.visit(stmt)
        self.code.dedent()
    
    #--------------------------------------------------------------------------
    # cw_ast.expr Handlers
    #--------------------------------------------------------------------------
    def render_BoolOp(self, bool_op):
        op = self.visit_render(bool_op.op)
        values = [self.visit_render(val) for val in bool_op.values]
        fill = ' %s ' % op
        return '(' + fill.join(values) + ')'

    def render_BinOp(self, bin_op):
        left = self.visit_render(bin_op.left)
        op = self.visit_render(bin_op.op)
        right = self.visit_render(bin_op.right)
        return '(%s %s %s)' % (left, op, right)

    def render_UnaryOp(self, un_op):
        op = self.visit_render(un_op.op)
        operand = self.visit_render(un_op.operand)
        return '(%s %s)' % (op, operand)

    def render_Lambda(self, lambda_node):
        args = self.visit_render(lambda_node.args)
        body = self.visit_render(lambda_node.body)
        return '(lambda %s: %s)' % (args, body)

    def render_IfExp(self, if_exp):
        test = self.visit_render(if_exp.test)
        body = self.visit_render(if_exp.body)
        orelse = self.visit_render(if_exp.orelse)
        return '(%s if %s else %s)' % (body, test, orelse)
    
    def render_Dict(self, dict_node):
        keys = [self.visit_render(key) for key in dict_node.keys]
        values = [self.visit_render(val) for val in dict_node.values]
        items = []
        for key, val in zip(keys, values):
            items.append('%s: %s' % (key, val))
        return '{' + ', '.join(items) + '}'

    def render_Set(self, set_node):
        values = [self.visit_render(val) for val in set_node.elts]
        return '{' + ', '.join(values) + '}'

    def render_ListComp(self, list_comp):
        elt = self.visit_render(list_comp.elt)
        gens = [self.visit_render(gen) for gen in list_comp.generators]
        return '[%s %s]' % (elt, ' '.join(gens))
    
    def render_SetComp(self, set_comp):
        elt = self.visit_render(set_comp.elt)
        gens = [self.visit_render(gen) for gen in set_comp.generators]
        return '{%s %s}' % (elt, ' '.join(gens))

    def render_DictComp(self, dict_comp):
        key = self.visit_render(dict_comp.key)
        value = self.visit_render(dict_comp.value)
        gens = [self.visit_render(gen) for gen in dict_comp.generators]
        return '{%s: %s %s}' % (key, value, ' '.join(gens))

    def render_GeneratorExp(self, gen_exp):
        elt = self.visit_render(gen_exp.elt)
        gens = [self.visit_render(gen) for gen in gen_exp.generators]
        return '(%s %s)' % (elt, ' '.join(gens))

    def render_Yield(self, yield_node):
        if yield_node.value:
            value = self.visit_render(yield_node.value)
        else:
            value = None

        if value:
            res = 'yield %s' % value
        else:
            res = 'yield'

        return res

    def render_Compare(self, compare):
        left = self.visit_render(compare.left)
        ops = [self.visit_render(op) for op in compare.ops]
        cmpts = [self.visit_render(cmpt) for cmpt in compare.comparators]

        items = [left]
        for op, cmpt in zip(ops, cmpts):
            items.append(op)
            items.append(cmpt)
        
        return '(' + ' '.join(items) + ')'

    def render_Call(self, call):
        func = self.visit_render(call.func)
        args = [self.visit_render(arg) for arg in call.args]
        keywords = [self.visit_render(kw) for kw in call.keywords]
        
        if call.starargs:
            starargs = '*' + self.visit_render(call.starargs)
        else:
            starargs = None
        
        if call.kwargs:
            kwargs = '**' + self.visit_render(call.kwargs)
        else:
            kwargs = None

        items = args + keywords
        if starargs:
            items.append(starargs)
        if kwargs:
            items.append(kwargs)

        return '%s(%s)' % (func, ', '.join(items))

    def render_Repr(self, repr_node):
        value = self.visit_render(repr_node.value)
        return '`%s`' % value

    def render_Num(self, num):
        res = repr(num.n)
        if res.startswith('-'):
            res = '(%s)' % res
        return res

    def render_Str(self, str_node):  
        return repr(str_node.s)

    def render_Attribute(self, attribute):
        value = self.visit_render(attribute.value)
        attr = attribute.attr
        return '%s.%s' % (value, attr)

    def render_Subscript(self, subscript):
        value = self.visit_render(subscript.value)
        slice = self.visit_render(subscript.slice)
        return '%s[%s]' % (value, slice)

    def render_Name(self, name):
        return name.id

    def render_List(self, list_node):
        elts = [self.visit_render(elt) for elt in list_node.elts]
        return '[' + ', '.join(elts) + ']'

    def render_Tuple(self, tuple_node):
        elts = [self.visit_render(elt) for elt in tuple_node.elts]
        return '(' + ', '.join(elts) + ')'
    
    def render_CName(self, cname):
        if self.cdef_stmt_context:
            cdef_mods = self.cdef_stmt_context.pop()
        else:
            cdef_mods = None
        
        mods, type_node = self.extract_reference_types(cname.ctype)
        name = self.apply_reference_types(mods, cname.name)
        type_name = self.visit_render(type_node)
        
        if isinstance(type_node, cw_ast.CFunctionType):
            res = type_name.replace('{__name__}', name)
            if cdef_mods:
                res = '%s %s' % (cdef_mods, res)
        else:
            if cdef_mods:
                res = '%s %s %s' % (cdef_mods, type_name, name)
            else:
                res = '%s %s' % (type_name, name)
        
        return res.strip()
    
    #--------------------------------------------------------------------------
    # cw_ast.slice Handlers
    #--------------------------------------------------------------------------
    def render_Ellipsis(self, ellipsis):
        return '...'

    def render_Slice(self, slice_node):
        if slice_node.lower:
            lower = self.visit_render(slice_node.lower)
        else:
            lower = None

        if slice_node.upper:
            upper = self.visit_render(slice_node.upper)
        else:
            upper = None

        if slice_node.step:
            step = self.visit_render(slice_node.step)
        else:
            step = None

        if lower:
            if step:
                if upper:
                    items = [lower, step, upper]
                else:
                    items = [lower, step]
            else:
                if upper:
                    items = [lower, '', upper]
                else:
                    items = [lower]
        elif step:
            if upper:
                items = ['', step, upper]
            else:
                items = ['', step]
        elif upper:
            items = ['', '', upper]
        else:
            items = ['', '']
        
        return ', '.join(items)

    def render_ExtSlice(self, ext_slice):
        dims = [self.visit_render(dim) for dim in ext_slice.dims]
        return ', '.join(dims)

    def render_Index(self, index):
        return self.visit_render(index.value)

    #--------------------------------------------------------------------------
    # cw_ast.boolop handlers
    #--------------------------------------------------------------------------
    def render_And(self, and_node):
        return 'and'

    def render_Or(self, or_node):
        return 'or'

    #--------------------------------------------------------------------------
    # cw_ast.operator handlers
    #--------------------------------------------------------------------------
    def render_Add(self, add):
        return '+'

    def render_Sub(self, sub):
        return '-'

    def render_Mult(self, mult):
        return '*'

    def render_Div(self, div):
        return '/'

    def render_Mod(self, mod):
        return '%'

    def render_Pow(self, pow_node):
        return '**'

    def render_LShift(self, lshift):
        return '<<'

    def render_RShift(self, rshift):
        return '>>'

    def render_BitOr(self, bitor):
        return '|'

    def render_BitAnd(self, bitand):
        return '&'

    def render_FloorDiv(self, floordiv):
        return '//'

    #--------------------------------------------------------------------------
    # cw_ast.unaryop handlers
    #--------------------------------------------------------------------------
    def render_Invert(self, invert):
        return '~'

    def render_Not(self, not_node):
        return 'not'

    def render_UAdd(self, uadd):
        return '+'

    def render_USub(self, usub):
        return '-'

    #--------------------------------------------------------------------------
    # cw_ast.cmpop handlers
    #--------------------------------------------------------------------------
    def render_Eq(self, eq):
        return '=='

    def render_NotEq(self, not_eq):
        return '!='

    def render_Lt(self, lt):
        return '<'

    def render_LtE(self, lte):
        return '<='

    def render_Gt(self, gt):
        return '>'

    def render_GtE(self, gte):
        return '>='

    def render_Is(self, is_node):
        return 'is'

    def render_IsNot(self, is_not):
        return 'is not'

    def render_In(self, in_node):
        return 'in'

    def render_NotIn(self, not_in):
        return 'not in'
    
    #--------------------------------------------------------------------------
    # cw_ast.comprehension Handler
    #--------------------------------------------------------------------------
    def render_comprehension(self, comprehension):
        target = self.visit_render(comprehension.target)
        iter = self.visit_render(comprehension.iter)
        ifs = ['if ' + self.visit_render(_if) for _if in comprehension.ifs]
        if ifs:
            res = 'for %s in %s %s' % (target, iter, ' '.join(ifs))
        else:
            res = 'for %s in %s' % (target, iter)
        return res

    #--------------------------------------------------------------------------
    # cw_ast.arguments Handler
    #--------------------------------------------------------------------------
    def render_arguments(self, args_node):
        sentinel = object()
        args = args_node.args
        defaults = args_node.defaults
        defaults = [sentinel] * (len(args) - len(defaults)) + defaults

        items = []
        for arg, default in zip(args, defaults):
            sarg = self.visit_render(arg)
            if default is not sentinel:
                sdef = self.visit_render(default)
                items.append('%s=%s' % (sarg, sdef))
            else:
                items.append(sarg)

        if args_node.vararg:
            vararg = '*' + self.visit_render(args_node.vararg)
        else:
            vararg = None

        if args_node.kwarg:
            kwarg = '**' + self.visit_render(args_node.kwarg)
        else:
            kwarg = None

        if vararg:
            items.append(vararg)
        if kwarg:
            items.append(kwarg)

        return ', '.join(items)

    #--------------------------------------------------------------------------
    # cw_ast.keyword Handler
    #--------------------------------------------------------------------------
    def render_keyword(self, kwd):
        arg = kwd.arg
        value = self.visit_render(kwd.value)
        return '%s=%s' % (arg, value)

    #--------------------------------------------------------------------------
    # cw_ast.alias Handler
    #--------------------------------------------------------------------------
    def render_alias(self, alias):
        name = alias.name
        if alias.asname:
            res = '%s as %s' % (name, alias.asname)
        else:
            res = name
        return res

    #--------------------------------------------------------------------------
    # cw_ast.cdefmodifier Handlers
    #--------------------------------------------------------------------------
    def render_Extern(self, extern):
        return 'extern'

    def render_Inline(self, inline):
        return 'inline'

    def render_Public(self, public):
        return 'public'

    def render_Api(self, api):
        return 'api'
   
    #--------------------------------------------------------------------------
    # cw_ast.ctype Handlers
    #--------------------------------------------------------------------------
    def render_TypeName(self, type_name):
        res = ''
        if type_name.const:
            res = 'const '
        return res + self.visit_render(type_name.name)

    def render_CFunctionType(self, func_type):
        args = self.visit_render(func_type.args)
        stem = '({__name__})(%s)' % args
        mods, type_node = self.extract_reference_types(func_type.returns)
        name = self.apply_reference_types(mods, stem)
        returns = self.visit_render(type_node)
        if isinstance(type_node, cw_ast.CFunctionType):
            res = returns.replace('{__name__}', name)
        else:
            res = '%s %s' % (returns, name)
        return res

    #--------------------------------------------------------------------------
    # Pointer and Array extract
    #--------------------------------------------------------------------------
    def extract_reference_types(self, node):
        mods = []
        if isinstance(node, (cw_ast.Reference)):
            mods.append('&')
            node = node.value

        while isinstance(node, (cw_ast.Pointer, cw_ast.Array)):
            if isinstance(node, cw_ast.Pointer):
                if node.const:
                    mods.append('const')
                mods.append('*')
            else:
                dim = node.dim
                if dim is None:
                    dim = ''
                mods.append('[%s]' % dim)
            node = node.value
        
        i = 0
        while i < (len(mods) - 1):
            if (mods[i][0] == '[' and mods[i][-1] == ']') or \
                    mods[i] == 'const' or mods[i + 1] == 'const':
                i += 1
            elif mods[i] != mods[i + 1]:
                mods.insert(i + 1, '()')
                i += 2
            else:
                i += 1
        return mods, node

    def apply_reference_types(self, mods, name):
        sub_str = '%s%s'
        for mod in mods:
            if mod == '*':
                name = sub_str % (mod, name)
            elif mod == '&':
                name = sub_str % (mod, name)
            elif mod == '()':
                name = '(%s)' % name
            elif mod == 'const':
                name = 'const %s' % name
            else:
                name = sub_str % (name, mod)
        return name

   
